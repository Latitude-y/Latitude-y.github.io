<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一和零</title>
      <link href="/2022/07/10/%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
      <url>/2022/07/10/%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs &#x3D; [“10”, “0001”, “111001”, “1”, “0”], m &#x3D; 5, n &#x3D; 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2：</p><p>输入：strs &#x3D; [“10”, “0”, “1”], m &#x3D; 1, n &#x3D; 1<br>输出：2<br>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>力扣链接：<a href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></p></blockquote></blockquote><blockquote><h2 id="推导思路"><a href="#推导思路" class="headerlink" title="推导思路"></a>推导思路</h2><blockquote><p>初看不会，再看还是不会…..</p><p>但是隐约觉得m和n在里面就是背包容量。所以哪个是背包容量？两个都是！</p></blockquote></blockquote><blockquote><blockquote><ol><li><p>确定dp数组含义</p><p>dp[i][j]:最多有i个0和j个1的数组中的最大子集个数为dp[i][j]。真绕啊…</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="2"><li><p>确定递推公式</p><p>dp[i][j]可以由前一个strs数组里的字符串推导而来，每个字符串有<code>zero</code>个0，<code>one</code>个1。</p><p>所以参考以前的背包问题可得：</p><p><code>dp[i][j]=dp[i-zero][j-one]+1</code></p><p>如果不放入该字符串，则：</p><p><code>dp[i][j]=dp[i][j]</code></p><p>所以递推公式为：</p><p><code>dp[i][j]=Math.max(dp[i][j],dp[i-zero][j-one]+1)</code></p><p>这里的<code>zero</code>和<code>one</code>就是物品质量，<code>1</code>就是物品价值。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="3"><li><p>dp数组初始化</p><p>物品价值不会是负数，所以都初始化为0就好了。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="4"><li><p>确定遍历顺序</p><p>依然中规中矩，遍历物品那层必须在外面，遍历背包容量那两层必须在里面，这个是不可以变得，之前有说过，因为遍历背包是逆序的。但是里面两层背包的遍历顺序可以随意。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li><p>举例推导dp数组</p><p>我还有些蒙的，把打印结果放下面吧：</p><p><img src="/pictures/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/5.png"></p></li></ol></blockquote></blockquote><blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 一和零_test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs=&#123;<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;111001&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">3</span>;</span><br><span class="line">        findMaxForm(strs,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;strs[i].length();l++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i].charAt(l)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    one++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    zero++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(strs[i]+<span class="string">&quot;=zero---&gt;&quot;</span>+zero+<span class="string">&quot;  &quot;</span>+<span class="string">&quot;one---&gt;&quot;</span>+one);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j1=m;j1&gt;=zero;j1--)&#123;  <span class="comment">//背包0</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j2=n;j2&gt;=one;j2--)&#123;    <span class="comment">//背包1</span></span><br><span class="line">                    dp[j1][j2]=Math.max(dp[j1][j2],dp[j1-zero][j2-one]+<span class="number">1</span>);</span><br><span class="line">                    System.out.print(<span class="string">&quot;dp[&quot;</span>+j1+<span class="string">&quot;]&quot;</span>+<span class="string">&quot;[&quot;</span>+j2+<span class="string">&quot;]&quot;</span>+<span class="string">&quot;=&quot;</span>+dp[j1][j2]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[m][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git学习（一）</title>
      <link href="/2022/07/02/Git(1)/"/>
      <url>/2022/07/02/Git(1)/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="远程数据库和本地数据库"><a href="#远程数据库和本地数据库" class="headerlink" title="远程数据库和本地数据库"></a>远程数据库和本地数据库</h2><blockquote><ul><li><p><strong>远程数据库</strong>：配有专用的服务器，为了多人共享而建立的数据库。</p></li><li><p><strong>本地数据库</strong>：为了方便用户个人使用，在自己的机器上配置的数据库。</p></li></ul></blockquote></blockquote><blockquote><h2 id="修改记录的提交"><a href="#修改记录的提交" class="headerlink" title="修改记录的提交"></a>修改记录的提交</h2><blockquote><p>要把文件或目录的添加和变更保存到数据库，就需要进行提交。执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也被称为revision）。</p><p><img src="/pictures/Git/1.png"><strong>注意</strong></p><ul><li><p>不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。</p></li><li><p>查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。<br>以下是Git的标准注解：</p></li><li><pre><code class="java">第1行：提交修改内容的摘要第2行：空行第3行以后：修改的理由</code></pre></li></ul></blockquote></blockquote><blockquote><h2 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h2><p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间<strong>索引</strong>区域的状态保存到数据库。</p><p>因此，要提交文件，首先需要把文件加入到索引区域中。</p><p><img src="/pictures/Git/2.png"></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>目标和</title>
      <link href="/2022/06/28/%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
      <url>/2022/06/28/%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><ul><li>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</li></ul><p>示例 1：</p><p>输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 &#x3D; 3<br>+1 - 1 + 1 + 1 + 1 &#x3D; 3<br>+1 + 1 - 1 + 1 + 1 &#x3D; 3<br>+1 + 1 + 1 - 1 + 1 &#x3D; 3<br>+1 + 1 + 1 + 1 - 1 &#x3D; 3</p><p>示例 2：</p><p>输入：nums &#x3D; [1], target &#x3D; 1<br>输出：1</p><p>力扣链接：<a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p></blockquote></blockquote><blockquote><h2 id="推导思路"><a href="#推导思路" class="headerlink" title="推导思路"></a>推导思路</h2><blockquote><p>这道题硬做是难的，可以通过暴力搜索的方式，但是时间复杂度会超。</p><p>因为我们最后目标是要得到<code>target</code>，所以要想办法去变换题目思路找出什么是背包容量什么是物品重量。</p><p>在这里，所有数字总和为<code>sum</code>，而数字前符号为<code>+</code>的总和设为<code>plus</code>，则数字前符号为<code>-</code>的总和为<code>sum-plus</code>，所以可得：<code>target=plus-（sum-plus）</code></p><p>变形一下可得：<code>plus=（target+sum）/2</code>，此时<code>plus</code>则是我们需要的背包容量。</p><p>当然背包容量不可能为小数，所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((sum+target)%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其次所有数的总和也不可能小于<code>target</code>的绝对值，所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Math.abs(target)&gt;sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>我开始到这还不明白，但仔细想一下，这不就是从<code>nums</code>数组中放东西到容量为<code>plus</code>的背包中，然后看有几种方式可以凑成数字前符号为<code>+</code>的数字总和即<code>plus</code>吗？</strong></p></blockquote></blockquote><blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><p>以上都明确了，后面就可以按动规五部曲走了</p><ol><li><p><strong>确定dp数组含义</strong></p><p>dp[j]：装满容量为j的背包有dp[j]种方法。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="2"><li><p><strong>确定递推公式</strong></p><p>这里要提一下，问题是要求有几种方式，和以往求某个中间态的数值不一样，所以递推公式略有不同。这里递推公式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]+=dp[j-nums[i]</span><br></pre></td></tr></table></figure><p>这里只需要记住：</p><p><strong>以后求组合个数的问题，就是这种递推公式，如果要把每种情况都罗列出来没办法用动态规划，只能回溯暴力搜索出。</strong></p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="3"><li><p><strong>dp数组初始化</strong></p><p>要将<code>dp[0]=1</code>，首先是因为如果不赋予一个初始值的话，后面所有情况得出的值都是0，其次很好理解，装满容量为0的背包只有一种方法，就是啥都不装。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="4"><li><p><strong>确定遍历顺序</strong></p><p>不多说了，典型的0-1背包问题，先遍历物品再遍历背包。</p><p><strong>后面会针对0-1背包和完全背包以及组合数和排列数做一下总结。</strong></p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li><p><strong>举例推导dp数组</strong></p><p>略</p></li></ol></blockquote></blockquote><blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 目标和_test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> target=<span class="number">1</span>;</span><br><span class="line">        findTargetSumWays(nums,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> plus;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">            sum+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sum+target)%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(target)&gt;sum)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        plus=(sum+target)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[plus+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;   <span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=plus;j&gt;=nums[i];j--)&#123;   <span class="comment">//背包</span></span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[plus]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最后一块石头的重量</title>
      <link href="/2022/06/26/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
      <url>/2022/06/26/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，<strong>最多只会剩下一块</strong>石头。返回此石头<strong>最小的可能重量</strong>。如果没有石头剩下，就返回 0。</p><p>示例 1：</p><p>输入：stones &#x3D; [2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>示例 2：</p><p>输入：stones &#x3D; [31,26,33,21,40]<br>输出：5</p><p>力扣链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p></blockquote></blockquote><blockquote><h2 id="推导思路"><a href="#推导思路" class="headerlink" title="推导思路"></a>推导思路</h2><blockquote><p>首先要分析一下这道题，简化一下这道题的问题。题目那么长，总结到底就是说如何<strong>将一堆石头分为重量最接近的两堆</strong>。</p><p>明确这个后就可以按动规五部曲进行分析了。</p></blockquote></blockquote><blockquote><blockquote><ol><li><p>确定dp数组含义</p><p><code>dp[j]</code>可以表示为容量为<code>j</code>的背包中最多可以装的石头重量。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="2"><li><p>确定递推公式</p><p>直接套用0-1背包的公式，<code>dp[j]</code>可由以下两处推导而来：</p><ul><li><p>不放石头i时的背包重量，即<code>dp[j]</code></p></li><li><p>放入石头i时的背包重量，即<code>dp[j-stones[i]]+stones[i]</code></p></li></ul><p>综上递推公式为：</p><p><code>dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i])</code></p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="3"><li><p>dp数组初始化</p><p>因为重量不会是负值，所以我的习惯是默认都赋值为0就好了。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="4"><li><p>遍历顺序</p><p>中规中矩，先遍历物品，再遍历背包，这里物品石头。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li><p>举例推导dp数组</p><p>我的习惯是在纸上先推导第一轮，再用IDEA打印验证推导，因为dp数组开始没有赋值，初始值就为0了。</p><p><img src="/pictures/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/3.png"></p></li></ol></blockquote></blockquote><blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>推导出dp数组后，再想一下为啥要推出dp数组。</p><p>开始分析说过，就是为把石头分成重量最相似的两堆，所以其中一堆是<code>dp[sum/2]</code>,其中一堆是<code>sum-dp[sum/2]</code>。</p><p>因为<code>sum/2</code>是向下取整，所以<code>sum-dp[sum/2]-dp[sum/2]</code>一定大于0，但我还是用了一个绝对值函数。</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test_LastStone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] stones=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        LastStone(stones);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">LastStone</span><span class="params">(<span class="type">int</span>[] stones)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s:stones)&#123;</span><br><span class="line">            sum+=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">                System.out.print(dp[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>组合问题</title>
      <link href="/2022/06/24/%E7%BB%84%E5%90%88/"/>
      <url>/2022/06/24/%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p>示例 1：</p><p>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><p>示例 2：</p><p>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]]</p><p><strong>力扣链接：</strong> <a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p></blockquote></blockquote><blockquote><h2 id="推导思路"><a href="#推导思路" class="headerlink" title="推导思路"></a>推导思路</h2><blockquote><p><strong>回溯问题</strong>最重要的就是要把问题抽象成一颗<strong>N叉树</strong>。这道题可以抽象成如下的一棵树：</p><p><img src="/pictures/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.png"></p></blockquote></blockquote><blockquote><blockquote><p><strong>1. 确定函数返回值以及函数参数</strong></p><p>根据力扣给的代码格式，很容易可知函数的返回值，并且返回值中的泛型类型也是list集合，所以可知，一个存放最终返回结果，一个存放每次的单一结果，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//每次的结果</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; list2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//返回结果</span></span><br></pre></td></tr></table></figure><p>这里为了减少函数中的参数个数，选择将其作为全局变量。</p><p><strong>函数参数</strong>：除了题目给出的<code>n</code>和<code>k</code>外，还要考虑一个<code>index</code>来记录本次递归从哪里开始。因此所有参数有<code>n,k,index</code>。</p></blockquote></blockquote><blockquote><blockquote><p><strong>2. 回溯函数的终止条件</strong></p><p>这里逻辑很简单，其实就是，每次取得的结果<code>list1</code>已经取得了<code>k</code>个数后，则本次递归结束，<code>return</code>就好。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(list1.size()==k)&#123;</span><br><span class="line">           list2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1));<span class="comment">//new一个新的集合，并且进行拷贝</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>这里重点说明下</strong>：<strong>为什么代码块中不能写成</strong><code>list2.add(list1)</code>？</p><p><strong>因为通俗点说就是，list集合共用一个内存地址，一个变则所有变，所以需要new一个新的集合再进行拷贝。常规数据类型不会存在这种问题是因为常规数据类型会自动装箱。</strong></p><p>这里是写这道题时踩得大坑，希望注意！</p></blockquote></blockquote><blockquote><blockquote><p><strong>3. 单层搜索的过程</strong></p><p>以下这张图很形象了我觉得，横向代表for循环，纵向代表递归</p><p><img src="/pictures/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n;i++)&#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">            diff(n,k,i+<span class="number">1</span>);</span><br><span class="line">            list1.remove(list1.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 组合 &#123;</span><br><span class="line">    List&lt;Integer&gt; list1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; l=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        组合 z=<span class="keyword">new</span> 组合();</span><br><span class="line">        l=z.combine(n,k);</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        diff(n,k,<span class="number">1</span>);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">diff</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.size()==k)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 重点：list2.add(list1) 不可取，因为list集合共用一个内存地址，一个变则所有变，所以需要new一个新的集合再进行拷贝</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            list2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1));<span class="comment">//new一个新的集合，并且进行拷贝</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n;i++)&#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">            diff(n,k,i+<span class="number">1</span>);</span><br><span class="line">            list1.remove(list1.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><h2 id="优化——剪枝"><a href="#优化——剪枝" class="headerlink" title="优化——剪枝"></a>优化——剪枝</h2><blockquote><p>意思就是有的遍历没必要进行了，很好理解，这里直接放卡尔大哥的图了：</p><p><img src="/pictures/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/3.png"><br>剪枝需要在每层for循环遍历的位置做手脚，也就是这段代码位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n;i++)&#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">            diff(n,k,i+<span class="number">1</span>);</span><br><span class="line">            list1.remove(list1.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><ol><li><p>已经选择元素的个数：list1.size（）；</p></li><li><p>还需要选择元素的个数：k-list1.size（）；</p></li><li><p>所以集合中最多只能从：n-（k-list1.size（））+1开始遍历</p></li></ol></blockquote></blockquote><blockquote><blockquote><p>所以只需要优化循环里面的<code>n</code>即可，优化代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n-(k-list1.size())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">            diff(n,k,i+<span class="number">1</span>);</span><br><span class="line">            list1.remove(list1.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题——滚动数组</title>
      <link href="/2022/06/23/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"/>
      <url>/2022/06/23/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p><strong>有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</strong></p></blockquote></blockquote><blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>背包最大重量：4</strong></p><table><thead><tr><th align="center"></th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">物品0</td><td align="center">1</td><td align="center">15</td></tr><tr><td align="center">物品1</td><td align="center">3</td><td align="center">20</td></tr><tr><td align="center">物品2</td><td align="center">4</td><td align="center">30</td></tr></tbody></table></blockquote><p><img src="/pictures/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/1.png" alt="1"></p><hr><p><strong>解决同一个问题，只不过这次压缩二维数组的状态，只使用一维数组。依然是以下动规五部曲。</strong></p><hr><blockquote><h2 id="推导思路"><a href="#推导思路" class="headerlink" title="推导思路"></a>推导思路</h2><blockquote><ol><li><p><strong>确定dp数组含义</strong></p><p>一维数组中，<strong>dp[j]</strong> 表示，在容量为j的背包中，物品最大价值总和。</p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="2"><li><p><strong>确定递推公式</strong></p><ul><li><p><strong>不放物品i</strong>：意思就是当前容量背包的最大物品价值就是上一状态容量背包的最大价值，理解为不放物品i，即 <code>dp[j]=dp[j]</code></p></li><li><p><strong>放物品i</strong>：意思就是容量为<code>j-weight[i]</code>的背包中放入物品<code>i</code>,即<code>dp[j]=dp[j-weight[i]+value[i]</code></p></li></ul><p>两者取最大值，即：</p><p><code>dp[j]=MAX(dp[j],dp[j-weight[i]+value[i])</code></p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="3"><li><strong>dp数组初始化</strong><ul><li><code>dp[0]</code> 初始化为0</li><li>因为物品价值均为正数，所以均初始化为0即可，如果有负数就应该视情况而定了。</li></ul></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="4"><li><p><strong>确定遍历顺序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历顺序是 <strong>先遍历物品，再遍历背包</strong></p><ul><li><p><strong>问题一：为什么第二层循环倒叙？</strong></p><p>如果进行手动推导，可以发现，如果正序遍历，则每次都会重复加上前一状态的值倒叙遍历可以避免出现这样的状况。</p></li><li><p><strong>问题二：为什么二维数组中遍历不需要倒叙？</strong></p><p>因为对于二维数组<code>dp[i][j]</code>,都是由上一状态<code>dp[i-1][j]</code>得来，并不会把本层的<code>dp[i][j]</code>覆盖掉。相当于有一个其他的数组记录了上一时刻的状态。</p></li><li><p><strong>问题三：遍历顺序能互换吗？</strong></p><p><strong>不能！</strong> 因为第二层是倒叙，如果互换后那么每次背包里只会放入一个物品。</p></li></ul></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li><p><strong>举例推导dp数组</strong></p><table><thead><tr><th align="center">背包容量</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">物品0</td><td align="center">0</td><td align="center">15</td><td align="center">15</td><td align="center">15</td><td align="center">15</td></tr><tr><td align="center">物品1</td><td align="center">0</td><td align="center">15</td><td align="center">15</td><td align="center">20</td><td align="center">35</td></tr><tr><td align="center">物品2</td><td align="center">0</td><td align="center">15</td><td align="center">15</td><td align="center">20</td><td align="center">35</td></tr></tbody></table></li></ol></blockquote></blockquote><hr><blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZeAndOn</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] v,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>];   <span class="comment">//初始化均为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;w.length;i++)&#123;   <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=w[i];j--)&#123;    <span class="comment">//遍历背包   为什么逆序？  通过手动推导，发现如果正序会重复计算上一次状态的值</span></span><br><span class="line">                <span class="type">int</span> a=dp[j];</span><br><span class="line">                <span class="type">int</span> b=dp[j-w[i]]+v[i];</span><br><span class="line">                dp[j]=Math.max(a,b);</span><br><span class="line">                System.out.print(dp[j]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*        for(int end:dp)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(end);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="/2022/06/21/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/21/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1></blockquote><blockquote><blockquote><p><strong>有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</strong></p></blockquote></blockquote><blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>背包最大重量：4</strong></p><table><thead><tr><th align="center"></th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">物品0</td><td align="center">1</td><td align="center">15</td></tr><tr><td align="center">物品1</td><td align="center">3</td><td align="center">20</td></tr><tr><td align="center">物品2</td><td align="center">4</td><td align="center">30</td></tr></tbody></table></blockquote><p><img src="/pictures/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/1.png" alt="1"></p><hr><blockquote><h2 id="推导思路"><a href="#推导思路" class="headerlink" title="推导思路"></a>推导思路</h2><blockquote><p><strong>1. 确定DP数组含义</strong><br><strong>dp[i][j]</strong>:从下标为[0-i]的物品中任意取物品，放入容量为j的背包中，价值总和最大为多少。</p></blockquote></blockquote><blockquote><blockquote><p><strong>2. 确定递推公式</strong><br>dp[i][j]主要由两个方向推导而来:</p><ul><li><strong>dp[i-1][j]</strong>:当背包容量为j时，不放物品i时的最大价值，此时dp[i][j]&#x3D;dp[i-1][j]。</li><li><strong>dp[i-1][j-weight[i]]</strong>:当背包容量为j-weight[i]时，不放物品i时的最大价值，此时dp[i][j]&#x3D;dp[i-1][j-weight[i]]+value[i]。</li></ul><p>所以递归公式为：<br><code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-wight[i]]+value[i])</code></p></blockquote></blockquote><blockquote><blockquote><p><strong>3. dp数组初始化</strong></p><ul><li>当背包容量即j&#x3D;0时，dp[i][0]均为0;</li><li>当存放物品0即i&#x3D;0时，各个容量背包可存放的最大物品价值dp[0][j],当<code>j&lt;weight[i]</code>时,dp[0][j]均为<code>0</code>，当<code>j&gt;=weight[i]</code>时,dp[0][j]为<code>value[0]</code>。</li><li>因为其他的下标每次都会被覆盖，都初始化为<code>0</code>就好了。</li></ul></blockquote></blockquote><blockquote><blockquote><p><strong>4. 确定遍历顺序</strong></p><ul><li><p>先遍历物品再遍历背包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的⼤⼩ 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">     <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 这个是为了展现dp数组⾥元素的</span></span><br><span class="line">变化</span><br><span class="line">     <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 先遍历背包再遍历物品：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// weight数组的⼤⼩ 就是物品个数</span><br><span class="line">for(int j = 0; j &lt;= bagWeight; j++) &#123; // 遍历背包容量</span><br><span class="line"> for(int i = 1; i &lt; weight.size(); i++) &#123; // 遍历物品                </span><br><span class="line">     if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]        ;</span><br><span class="line">     else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>两种都可以！</strong></p><p>  <strong>为什么？</strong></p><p>  首先要先明白递归顺序，先看递归公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-wight[i]]+value[i])</span><br></pre></td></tr></table></figure><p>  可见当先遍历物品再遍历背包时，当前dp[i][j]来自左上方和正上方</p><p>  当先遍历背包再遍历物品时，同样是来自左上方和正上方，不影响当前dp[i][j]。</p><p>  所以遍历顺序在二维数组遍历中都可以，只不过先遍历物品再遍历背包更好理解。</p><p>  <img src="/pictures/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2.png" alt="2"></p></blockquote></blockquote><blockquote><blockquote><p><strong>5. 举例推导dp数组</strong></p><p>这里我的经验是可以直接用代码打印出每次递归后的dp数组会更直观点，也不用手动推导了，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">               System.out.print(dp[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">物品0</td><td align="center">0</td><td align="center">15</td><td align="center">15</td><td align="center">15</td><td align="center">15</td></tr><tr><td align="center">物品1</td><td align="center">0</td><td align="center">15</td><td align="center">15</td><td align="center">20</td><td align="center">35</td></tr><tr><td align="center">物品2</td><td align="center">0</td><td align="center">15</td><td align="center">15</td><td align="center">20</td><td align="center">35</td></tr></tbody></table></blockquote></blockquote><hr><blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZeAndOn</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] v,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[w.length][sum+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;sum+<span class="number">1</span>;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(j&gt;=w[<span class="number">0</span>])&#123;</span><br><span class="line">               dp[<span class="number">0</span>][j]=v[<span class="number">0</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               dp[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//初始化dp数组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;     <span class="comment">//遍历物品</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;sum+<span class="number">1</span>;j++)&#123;    <span class="comment">//遍历背包</span></span><br><span class="line">               <span class="keyword">if</span>(w[i]&gt;j)&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="type">int</span> a=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                   <span class="type">int</span> b=dp[i-<span class="number">1</span>][j-w[i]]+v[i];</span><br><span class="line">                   dp[i][j]=Math.max(a,b);<span class="comment">//递推公式</span></span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Node2Vec学习笔记</title>
      <link href="/2022/06/21/Node2vec/"/>
      <url>/2022/06/21/Node2vec/</url>
      
        <content type="html"><![CDATA[<h1 id="Node2vec-Scalable-Feature-Learning-for-Networks"><a href="#Node2vec-Scalable-Feature-Learning-for-Networks" class="headerlink" title="Node2vec:Scalable Feature Learning for Networks"></a><a href="https://dl.acm.org/doi/abs/10.1145/2939672.2939754">Node2vec:Scalable Feature Learning for Networks</a></h1><blockquote><h2 id="论文的研究背景"><a href="#论文的研究背景" class="headerlink" title="论文的研究背景"></a>论文的研究背景</h2><blockquote><h3 id="本论文解决什么问题？（能否通过一个示例来说明拟解决的问题）"><a href="#本论文解决什么问题？（能否通过一个示例来说明拟解决的问题）" class="headerlink" title="本论文解决什么问题？（能否通过一个示例来说明拟解决的问题）"></a>本论文解决什么问题？（能否通过一个示例来说明拟解决的问题）</h3></blockquote></blockquote><p>在复杂网络领域主要有两类任务：网络节点分类和链路预测。在完成这两类问题之前首要解决的任务就是网络节点的嵌入。本篇论文要解决的问题就是如何设计一种既能保持节点邻居信息和体现网络信息而且又容易训练的模型来实现网络嵌入<br>比如将一篇文章构造成的词共现网络中，如果需要实现关键词提取或摘要提取等任务，则需要对该词共现网络进行节点分类以及链路预测，在此之前，首先就需要将该词共现网络中的节点信息向量化，成为词向量，也就是实现节点嵌入，再通过网络的嵌入信息完成更多下游任务。</p><blockquote><blockquote><h3 id="关于该问题，目前的相关工作有哪些？这些相关工作有何优缺点？（综述相关工作）"><a href="#关于该问题，目前的相关工作有哪些？这些相关工作有何优缺点？（综述相关工作）" class="headerlink" title="关于该问题，目前的相关工作有哪些？这些相关工作有何优缺点？（综述相关工作）"></a>关于该问题，目前的相关工作有哪些？这些相关工作有何优缺点？（综述相关工作）</h3></blockquote></blockquote><ul><li>手工提取特征的方式。特征需要依赖人手工定义，所以需要特定领域内专业人士来完成，而且手工提取特征步骤繁琐，对不同任务泛化能力差。</li><li>解优化函数的方式学习网络的表示特征。该方法面临一个计算效率和准确度的平衡问题，无法兼顾两者。</li><li>传统的降维方法（基于线性或非线性的降维技术）。有一定的效果，缺点是会涉及矩阵分解，运算量大，同时准确率也不高，而且有些方法只是针对特定的任务才有效果。</li></ul><blockquote><h2 id="论文的主要研究内容"><a href="#论文的主要研究内容" class="headerlink" title="论文的主要研究内容"></a>论文的主要研究内容</h2><blockquote><h3 id="针对已有工作的不足之处，本文提出了什么方法？（该方法为何有效？）该方法的基本思路是什么？主要创新点在哪？"><a href="#针对已有工作的不足之处，本文提出了什么方法？（该方法为何有效？）该方法的基本思路是什么？主要创新点在哪？" class="headerlink" title="针对已有工作的不足之处，本文提出了什么方法？（该方法为何有效？）该方法的基本思路是什么？主要创新点在哪？"></a>针对已有工作的不足之处，本文提出了什么方法？（该方法为何有效？）该方法的基本思路是什么？主要创新点在哪？</h3></blockquote></blockquote><p><strong>本文针对过去工作的不足之处，主要提出了以下三点优化：</strong></p><ul><li>优化目标函数，给定一个顶点，令其近邻顶点出现的概率最大；</li><li>提出有偏的随机游走路径采样策略；</li><li>使用Alias Sample方法进行顶点采样</li></ul><p>其中第二点，使用有偏的路径采样策略是本篇论文的核心思想，该方法引入两个超参数p和q来控制随机游走的策略。q越小，遍历到远处节点的概率越高，图的遍历越倾向于DFS，同时越趋向于表示图的同质性；p越小，图的遍历越倾向于BFS，越趋向于表示图的结构性。其中随机游走是p&#x3D;1，q&#x3D;1的一种特殊情况。</p><p><strong>本文的创新点主要有以下两点:</strong></p><ul><li>提出一种新的网络节点嵌入算法，其拓展性更好；</li><li>设计了有偏的随机游走算法，通过p，q等超参调节不同的游走情况，使其更加灵活的探索了网络的同质性或者结构性等信息。</li></ul><blockquote><blockquote><h3 id="阐述本文提出方法的技术细节"><a href="#阐述本文提出方法的技术细节" class="headerlink" title="阐述本文提出方法的技术细节"></a>阐述本文提出方法的技术细节</h3></blockquote></blockquote><p><strong>1. 优化目标函数</strong><br>论文将Skip-gram模型扩展到网络中来，优化以下目标函数：<br><img src="/pictures/Node2vec/1.png" alt="1"><br>为了使优化问题更容易处理，文章做了以下两个标准假设：</p><ul><li><strong>条件独立性假设</strong><br>条件独立给定一个顶点，其近邻顶点出现的概率与近邻集合中的其他顶点无关，得到以下公式：<br><img src="/pictures/Node2vec/2.png" alt="2"></li><li><strong>特征空间对称性假设</strong><br>源顶点和近邻顶点在特征空间中具有对称性，不管该顶点是源顶点还是近邻点Embedding表达是一样的，得到以下公式：<br><img src="/pictures/Node2vec/3.png" alt="3"><br>根据以上两个标准假设，原公式最终优化为以下目标函数：<br><img src="/pictures/Node2vec/4.png" alt="4"></li></ul><p><strong>2. 路径采样策略</strong><br>网络结构中存在两种性质，一是同质性，比如u和s1~s4处于同一个社区中，相连的边越少，权重越大，则同质性越强；二是结构性，比如u和s6的关系，它们虽然不接近，但是在彼此的社区中的角色类似，都是扮演中心节点的角色。相对应的，广度优先搜索BFS更适合探索网络的同质性，深度优先搜索DFS更适合探索网络的结构性。如下图所示。<br><img src="/pictures/Node2vec/5.png" alt="5"><br>Node2vec通过对参数的调节，可以在BFS和DFS之间进行权衡，同时探索网络的同质性和结构性。<br>在论文中，设定G&#x3D;（V，E）作为图，其中V为图的节点，E为图的边。对于任意一个节点u∈V，模拟一个长度为l的随机游走。设定ci为随机游走的第i个节点，其中第i个节点ci通过以下概率分布出现：<br><img src="/pictures/Node2vec/6.png" alt="6"><br>其中π_vx节点v和节点x的非归一化转移概率，Z为归一化常数。<br>文章通过设定π_vx&#x3D;α_pq (t,x)*w_vx来调整节点之间的转移概率，其中：<br><img src="/pictures/Node2vec/7.png" alt="7"><br>其中d_tx表示节点t和节点x之间的最短距离，<strong>p为返回参数（Return parameter）</strong>，**q为进出参数(In-out parameter)**。<br>由以上公式可知，q越小，遍历到远处节点的概率越高，图的遍历越倾向于DFS，同时越趋向于表示图的同质性；p越小，节点返回t的概率越大，图的遍历越倾向于BFS，越趋向于表示图的结构性。因此可以设置参数p、q的值来权衡图嵌入表达结果的倾向性。示例如下图所示。<br><img src="/pictures/Node2vec/8.png" alt="8">  </p><blockquote><h2 id="论文的实验结果"><a href="#论文的实验结果" class="headerlink" title="论文的实验结果"></a>论文的实验结果</h2><blockquote><h3 id="阐述本文的实验内容"><a href="#阐述本文的实验内容" class="headerlink" title="阐述本文的实验内容"></a>阐述本文的实验内容</h3></blockquote></blockquote><ul><li><p><strong>实验一:</strong> 将小说《悲惨世界》中的角色构建成含有77个节点和254条边的网络，设置不同的参数，使用Node2vec对图节点进行嵌入，验证Node2vec可以符合网络同质性和结构性的节点嵌入。<br>下图中顶部那副图对应p&#x3D;1,q&#x3D;0.5的情况。即p&#x3D;1,q&#x3D;0.5时算出每个节点的特征表示，然后根据特征表示进行聚类。在这个设置下，Node2vec发现了小说中经常互动的角色集群。<br>为了发现哪些节点具有相同的结构角色，使用相同的网络，设置p&#x3D;1,q&#x3D;2，使用Node2vec获取节点特征，然后根据获得的特征对节点进行聚类，结果如表图3底部所示。蓝色节点代表了小说中不同次要情节之间的桥梁，他们具有相似的结构角色。<br><img src="/pictures/Node2vec/9.png" alt="9">  </p></li><li><p><strong>实验二:</strong> 多标签分类。在多标签分类设置中，每个节点都从有限集L中分配一个或多个标签。在训练阶段，观察一定比例的节点及其所有标签。实验任务是预测剩余节点的标签。实验结果如下图所示，可见在多标签分类任务中Node2vec表现最好。<br>对比算法：Spectral Clustering、Deep Walk、LINE<br>使用的数据集：BlogCatalog(社交博客网站)、Protein-Protein Interactions(PPI)(蛋白质作用网络)、Wikipedia(词共现网络)<br><img src="/pictures/Node2vec/10.png" alt="10"><br><img src="/pictures/Node2vec/15.png" alt="15"> </p></li><li><p><strong>实验三:</strong> 参数灵敏度分析。使用标记数据和未标记数据之间的50-50分割来检查选择不同的参数如何影响Node2vec在BlogCatalog数据集上的性能。由下图可见，Node2vec的性能随着出入参数p和返回参数q的减少而提高，其他参数如d，r，l，k均能一定程度上提升Node2vec的性能，但有上限。<br><img src="/pictures/Node2vec/11.png" alt="11"> </p></li><li><p><strong>实验四:</strong> 扰动分析。文章分析了在信息有所缺失的网络情况下Node2vec的性能。第一种情况是在网络中随机选择缺失边，测试Node2vec随着网络中缺失边数量的增加性能的变化情况。第二种情况是在网络中随机选择节点对之间的噪声边缘，测试Node2vec随着网络中噪声边的增加性能的变化情况。如下图可见，随着数据集中缺失边越来越多，性能是越来越差的，但是总体来说下降斜率比较平缓；随着噪声越多，性能越差，但其下降速率在不断变慢。<br><img src="/pictures/Node2vec/12.png" alt="12"> </p></li><li><p><strong>实验五:</strong> 可扩展性分析。使用Node2vec学习节点表示，将Node2vec用于Erdos-Renyi图，设置Erdos-Renyi图的默认参数值从100增加到1000000个节点，平均度数为10，测试Node2vec的可扩展性。如下图可见，图的节点从100个增加到1000000个，Node2vec的时间复杂度在线性增加。<br><img src="/pictures/Node2vec/13.png" alt="13"> </p></li><li><p><strong>实验六:</strong> 链路预测。在链接预测中，文章使用一个删除了部分边的网络，并且预测这些丢失的边。文章按如下方式生成带标签的边的数据集：为了生成正样本，从网络中移除50%随机选择的边，同时确保在移除边后获得的剩余网络是连接的；为了生成负样本，从网络中随机抽取相同数量的节点对，这些节点对没有相互连接的边。由于之前没有将任何特征学习算法用于链路预测，因此文章还根据一些在链接预测中取得良好性能的流行启发式分数来评估Node2vec。如下图可见，Node2vec在arXiv数据集上取得了最好效果，相比于启发式方法中最好的Adamic-Adar提高了12.6%，并且Node2vec在所有网络中都优于DeepWalk和LINE。<br><img src="/pictures/Node2vec/14.png" alt="14"></p></li></ul><blockquote><blockquote><h3 id="本文方法的有效性是如何通过实验进行验证的？"><a href="#本文方法的有效性是如何通过实验进行验证的？" class="headerlink" title="本文方法的有效性是如何通过实验进行验证的？"></a>本文方法的有效性是如何通过实验进行验证的？</h3></blockquote></blockquote><p>在实验二多标签分类和实验六链路预测中，论文选取了三个比较主流的节点嵌入算法在三个不同领域的大型数据集上进行实验对比，在相同的实验条件下，均可得出Node2vec算法相较于其他算法的优越性。除此之外，论文还测试了不同参数对Node2vec算法的影响，并且考虑到网络本身的情况，比如缺失边以及噪声边的情况下，Node2vec的效能变化。总之在一系列的实验下，通过对比Node2vec相较于其他算法的优势以及对Node2vec本身结构的实验研究，十分全面的说明了Node2vec的有效性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown学习</title>
      <link href="/2022/06/17/MarkDown/"/>
      <url>/2022/06/17/MarkDown/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="#一级标题"></a>#一级标题</h1><p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;一级标题分割线</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="##二级标题"></a>##二级标题</h2><hr><p>-——————二级标题分割线</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="###三级标题"></a>###三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="####四级标题"></a>####四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="#####五级标题"></a>#####五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="######六级标题"></a>######六级标题</h6><hr><p><em>*斜体文本*</em><br><em>_斜体文本_</em></p><hr><p><strong>**粗体文本**</strong><br><strong>__粗体文本__</strong></p><hr><p><em><strong>***斜粗体文本***</strong></em><br><em><strong>___斜粗体文本___</strong></em></p><hr><p>~~~~删除线~~~~<br><u>&lt;u&gt;下划线&lt;&#x2F;u&gt;</u></p><hr><p>这是脚注[^foot]<br><img src="/pictures/%E8%84%9A%E6%B3%A8.png" alt="脚注" title="脚注"><br>[^foot]:脚注</p><hr><p>###无序列表</p><ul><li>+ 第一项，+号后面要加空格</li></ul><ul><li>* 第二项，要加空格</li></ul><ul><li>- 第三项，要加空格，+,-,*都可以</li></ul><p>###有序列表</p><ol><li>第一项</li><li>第二项</li><li>第三项，要加空格</li></ol><p>###嵌套列表</p><ol><li>1<ul><li>1.1</li><li>1.2</li><li>1.3</li></ul></li><li>2<ul><li>2.1</li></ul><ul><li>2.2</li></ul><ul><li>二级列表加四个空格</li></ul></li></ol><hr><blockquote><p>&gt;最外层嵌套</p><blockquote><p>&gt;&gt;第一层嵌套</p><blockquote><p>&gt;&gt;&gt;第二层嵌套</p><blockquote><p>&gt;&gt;&gt;&gt;第三层嵌套</p></blockquote></blockquote></blockquote></blockquote><ul><li>*列表加嵌套<br> &gt;最外层 (加四个空格缩进或一个tab键)</li></ul><hr><p> <code>print()</code>函数</p><p> 代码函数或者片段使用反引号 &#96;&#96; 将代码包起来</p><pre><code>    public static Boolean equal(int[] nums)&#123;    int sum=0;    for(int s:nums)&#123;        sum=sum+s;    &#125;    if(sum%2!=0)&#123;        return false;    &#125;    int sum2=sum/2;    int[] dp=new int[sum2+1];    for(int i=0;i&lt;nums.length;i++)&#123;        for(int j=sum2;j&gt;=nums[i];j--)&#123;            int a=dp[j];            int b=dp[j-nums[i]]+nums[i];            dp[j]=Math.max(a,b);            if(dp[j]==sum2)&#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><p>代码块可以给一个tab键然后开始放入代码块<br>或者三个反引号 ```    ```</p><hr><p>这是一个<a href="https://www.baidu.com/">链接</a><br>格式：<br>[ 链接名称 ]  (链接地址)</p><p><a href="https://www.baidu.com/">https://www.baidu.com</a><br>&lt;直接使用链接地址&gt;</p><hr><p>###放图片<br><img src="/pictures/au3.png" alt="C型" title="C"></p><p>![图片的代替文字]（图片url “图片标题”）</p><p><img src="/pictures/au3.png" width="70%" height="70%"></img><br>可以使用 &lt;</template>img src&#x3D;”url” width&#x3D;”” height&#x3D;”” &gt;方式指定图片大小</p><hr><p>###表格</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>勇士总冠军！库里FMVP！</title>
      <link href="/2022/06/17/FMVP/"/>
      <url>/2022/06/17/FMVP/</url>
      
        <content type="html"><![CDATA[<p><img src="/pictures/FMVP1.jpg" alt="FMVP1" title="FMVP1"><br><img src="/pictures/FMVP2.jpg" alt="FMVP2" title="FMVP2"><br><img src="/pictures/FMVP3.jpg" alt="FMVP3" title="FMVP3"><br><img src="/pictures/FMVP4.jpg" alt="FMVP4" title="FMVP4"><br><img src="/pictures/FMVP5.jpg" alt="FMVP5" title="FMVP5"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>来自M78星云的光之巨人的传说</title>
      <link href="/2022/05/13/%E5%A5%A5%E7%89%B9%E6%9B%BC/"/>
      <url>/2022/05/13/%E5%A5%A5%E7%89%B9%E6%9B%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>他是来自M78星云的光之巨人，为了追捕逃亡的宇宙怪兽百慕拉而来到地球。在龙森湖上空追击百慕拉时，他不慎与科学特别搜查队队员早田进所乘的战斗机相撞，导致早田坠机死亡。为了弥补自己的过失、以及挽救早田进的生命，奥特曼将自己的生命给予了早田，与之一心同体使其复活。之后，奥特曼与早田一起，为保卫地球而与众多凶暴的怪兽和邪恶的宇宙人展开了激烈的战斗。</strong></p><blockquote><h2 id="奥特曼的三种形态"><a href="#奥特曼的三种形态" class="headerlink" title="奥特曼的三种形态"></a>奥特曼的三种形态</h2></blockquote><blockquote><blockquote><h3 id="A型"><a href="#A型" class="headerlink" title="A型"></a>A型</h3></blockquote></blockquote><p><strong>奥特曼的初始皮套，由潜水服改造而来。第一代面具为了体现奥特曼嘴部的活动，而用合成橡胶裹在了面罩上使得演员能活动嘴巴。但后来圆谷认识到即使做了这些努力嘴部活动效果依然不明显还会导致面部变的凹凸不平，因此之后的面罩不再采用A型的制作方法。</strong><br><strong>在2006年剧场版《梦比优斯·奥特曼与奥特兄弟》和2008年的《大决战！超奥特8兄弟》中，出于情怀致敬的目的，特地让奥特曼以A型脸的形象登场。</strong></p><blockquote><blockquote><h4 id="具体特征"><a href="#具体特征" class="headerlink" title="具体特征"></a>具体特征</h4></blockquote></blockquote><ol><li>脸部崩坏</li><li>嘴部能够轻微地张开</li><li>基本上看不出胸肌</li><li>足部脚尖微微上翘</li></ol><blockquote><blockquote><h4 id="TV登场时段：第1话-第13话"><a href="#TV登场时段：第1话-第13话" class="headerlink" title="TV登场时段：第1话~第13话"></a>TV登场时段：第1话~第13话</h4></blockquote></blockquote><p><img src="/pictures/au1.png" alt="A" title="A"></p><blockquote><blockquote><h3 id="B型"><a href="#B型" class="headerlink" title="B型"></a>B型</h3></blockquote></blockquote><p><strong>这个皮套是因为A型皮套老化严重所以才被制作出来的，各方面（面部，胸前等）十分紧凑。B型皮套于1970年失窃，而并非在拍摄途中丢失。</strong><br><strong>在2009年剧场版《宇宙英雄之超银河传说》中，出于情怀致敬的目的，以及和佐菲、杰克等奥特战士作区分，特地让奥特曼再度以B型脸的形象登场出现。</strong></p><blockquote><blockquote><h4 id="具体特征："><a href="#具体特征：" class="headerlink" title="具体特征："></a>具体特征：</h4></blockquote></blockquote><ol><li>嘴型在三种皮套设计中最小</li><li>身上的花纹比较紧凑</li><li>足尖上翘很厉害</li></ol><blockquote><blockquote><h4 id="TV登场时段：第14话-第29话"><a href="#TV登场时段：第14话-第29话" class="headerlink" title="TV登场时段：第14话~第29话"></a>TV登场时段：第14话~第29话</h4></blockquote></blockquote><p><img src="/pictures/au2.png" alt="B" title="B"></p><blockquote><blockquote><h3 id="C型"><a href="#C型" class="headerlink" title="C型"></a>C型</h3></blockquote></blockquote><p><strong>作为奥特曼标准形象的C型，此皮套被制作出来的理由并非是因为B型皮套失窃（B型皮套失窃的时间点并不是在拍摄期间），而是为了改进B型的形象。奥特曼在后续的奥特系列作品中登场时，使用最多的也是C型脸形象。</strong></p><blockquote><blockquote><h4 id="具体特征：-1"><a href="#具体特征：-1" class="headerlink" title="具体特征："></a>具体特征：</h4></blockquote></blockquote><ol><li>身上的花纹结合了A型和B型的优点</li><li>胸肌十分的突出</li><li>足尖无上翘</li></ol><blockquote><blockquote><h4 id="TV登场时段：第30话-第39话"><a href="#TV登场时段：第30话-第39话" class="headerlink" title="TV登场时段：第30话~第39话"></a>TV登场时段：第30话~第39话</h4></blockquote></blockquote><p><img src="/pictures/au3.png" alt="C" title="C"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
